'use strict';

var require$$0$2 = require('i-html-parser');
var require$$0 = require('fs');
var require$$0$1 = require('selector-specificity');
var require$$1 = require('css-shorthand-parser');

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var readFile = require$$0.promises.readFile;
var purifier$1 = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(htmlInput, cssInput) {
    var css, html;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return readFile(cssInput, 'utf-8');
        case 2:
          css = _context.sent;
          _context.next = 5;
          return readFile(htmlInput, 'utf-8');
        case 5:
          html = _context.sent;
          // remove commented code
          css = css.replace(/\/\*[\s\S]*?\*\//g, '');
          html = html.replace(/<!--[\s\S]*?-->/g, '');

          // remove unnecessary white space
          css = css.replace(/\s{2,}/g, ' ').replace(/\s?([{},:;])\s?/g, function (_, $1) {
            return $1;
          }).replace(/\(\s/g, '(').replace(/\s([()])/g, function (_, $1) {
            return $1;
          }).trim();

          // .foo{color:red} -> .foo{color:red;}
          css = css.replace(/([^;])}/g, function (_, $1) {
            return "".concat($1, ";}");
          });

          // replace base64's semicolon
          // background-image: url(data:...);
          // background: url(data...) no-repeat ...;
          css = css.replace(/data:(.*?)\)([\s;])/g, function (_, $1, $2) {
            return "data:".concat($1.replace(/;/g, 'my-semicolon'), ")").concat($2);
          });
          return _context.abrupt("return", {
            html: html,
            css: css
          });
        case 12:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function purifier(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var purifier_1 = purifier$1;

var writeFile$1 = require$$0.promises.writeFile;
var fallback$1 = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(rawCss, output) {
    var cssText, selector, rules, prop, value;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          cssText = '';
          for (selector in rawCss) {
            cssText += "".concat(selector, " {");
            rules = rawCss[selector];
            for (prop in rules) {
              value = rules[prop];
              value = value.startsWith('url("data:image') ? value.replace(/my-semicolon/, ';') : value;
              cssText += "\r\n\t".concat(prop, ": ").concat(value, ";");
            }
            cssText += '\r\n}\r\n\r\n';
          }
          _context.next = 4;
          return writeFile$1("".concat(output, "/raw-css.css"), cssText);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function fallback(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var fallback_1 = fallback$1;

var spec$1 = require$$0$1;
var strategies$1 = {
  id: function id(nodes, name) {
    return nodes.filter(function (node) {
      return node.attrs.id === name;
    });
  },
  "class": function _class(nodes, name) {
    return nodes.filter(function (node) {
      var _node$attrs, _node$attrs$class;
      return (_node$attrs = node.attrs) === null || _node$attrs === void 0 ? void 0 : (_node$attrs$class = _node$attrs["class"]) === null || _node$attrs$class === void 0 ? void 0 : _node$attrs$class.hasOwnProperty(name);
    });
  },
  attribute: function attribute(nodes, name, value) {
    return nodes.filter(function (node) {
      return node.attrs[name] === value;
    });
  },
  universal: function universal(nodes) {
    return nodes;
  },
  // type selector
  element: function element(nodes, name) {
    return nodes.filter(function (node) {
      return node.tagName === name;
    });
  },
  child: function child(nodes) {
    var res = [];
    for (var i = 0, l = nodes.length; i < l; i++) {
      Array.prototype.push.apply(res, nodes[i].children);
    }
    return res;
  },
  sibling: function sibling(nodes) {
    var res = [];
    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = nodes[i];
      var children = node.parent.children;
      var index = children.indexOf(node);
      for (var _i = index + 1, _l = children.length; _i < _l; _i++) {
        res.push(children[_i]);
      }
    }
    return res;
  },
  descendant: function descendant(nodes) {
    var res = [];
    var getDescendantNodes = function getDescendantNodes(res, nodes) {
      for (var i = 0, l = nodes.length; i < l; i++) {
        var node = nodes[i];
        var type = node.type;
        if (type === 'text') {
          continue;
        }
        res.push(node);
        var children = node.children;
        if (children.length) {
          getDescendantNodes(res, children);
        }
      }
    };
    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = nodes[i];
      getDescendantNodes(res, node.children);
    }
    return res;
  },
  adjacent: function adjacent(nodes) {
    var res = [];
    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = nodes[i];
      var children = node.parent.children;
      var index = children.indexOf(node);
      var adjacentNode = children[index + 1];
      adjacentNode && res.push(adjacentNode);
    }
    return res;
  },
  'pseudo-class': function pseudoClass(nodes, name, value) {
    var strategy = pseudoClassStrategies[name];
    if (strategy) {
      return strategy(nodes, value);
    }
    return [];
  },
  'pseudo-element': function pseudoElement() {}
};
var pseudoClassStrategies = {
  'first-of-type': function firstOfType(nodes) {
    return [nodes[0]];
  },
  'last-of-type': function lastOfType(nodes) {
    return [nodes[nodes.length - 1]];
  },
  'before': function before(nodes) {
    return nodes;
  },
  'after': function after(nodes) {
    return nodes;
  },
  // 'link' (nodes) {
  //   return nodes
  // },
  'visited': function visited(nodes) {
    return nodes;
  } // 'hover' (nodes) {
  //   return nodes
  // }
};
var filterNodes$1 = function filterNodes(sourceNodes, selector) {
  var nodes = sourceNodes;
  var selectorNodes = spec$1.getNodes(selector);
  for (var i = 0, l = selectorNodes.length; i < l; i++) {
    var selectorNode = selectorNodes[i];
    var type = selectorNode.type,
      name = selectorNode.name,
      value = selectorNode.value;

    // .footer a:link,.footer a:visited
    if (type === 'combine') {
      var index = selector.indexOf(',');

      // remove duplicated node
      nodes = _toConsumableArray(new Set([].concat(_toConsumableArray(nodes), _toConsumableArray(filterNodes(sourceNodes, selector.slice(index + 1))))));
      break;
    }
    nodes = strategies$1[type](nodes, name, value, selectorNode) || [];
    if (!nodes.length) {
      break;
    }
  }
  return nodes;
};
var filterNodes_1 = filterNodes$1;

var deepClone$2 = function deepClone(o) {
  return JSON.parse(JSON.stringify(o));
};
var deepClone_1 = deepClone$2;

var deepClone$1 = deepClone_1;
var utils = {
  deepClone: deepClone$1
};

var _stylesMap;
var stylesMap$2 = (_stylesMap = {
  width: 'w',
  height: 'h',
  opacity: 'opacity',
  padding: 'shorthand-padding',
  'padding-top': 'pt',
  'padding-right': 'pr',
  'padding-bottom': 'pb',
  'padding-left': 'pl',
  margin: 'shorthand-margin',
  'margin-top': 'mt',
  'margin-right': 'mr',
  'margin-bottom': 'mb',
  'margin-left': 'ml',
  top: 'top',
  right: 'right',
  bottom: 'bottom',
  left: 'left',
  border: 'shorthand-border',
  'border-radius': 'rounded',
  'border-width': 'shorthand-border-width',
  'border-top-width': 'border-t',
  'border-right-width': 'border-r',
  'border-bottom-width': 'border-b',
  'border-left-width': 'border-l',
  'border-top-left-radius': 'rounded-tl',
  'border-top-right-radius': 'rounded-tr',
  'border-bottom-left-radius': 'rounded-bl',
  'border-bottom-right-radius': 'rounded-br',
  'border-color': 'shorthand-border-color',
  'border-top-color': 'border-t',
  'border-right-color': 'border-r',
  'border-bottom-color': 'border-b',
  'border-left-color': 'border-l',
  'border-style': 'shorthand-border-style',
  'border-top-style': 'border-t',
  'border-right-style': 'border-r',
  'border-bottom-style': 'border-b',
  'border-left-style': 'border-l',
  'border-top': 'shorthand-border-top',
  'border-right': 'shorthand-border-right',
  'border-bottom': 'shorthand-border-bottom',
  'border-left': 'shorthand-border-left',
  color: 'text',
  'font-size': 'text',
  'background-color': 'bg',
  'min-width': 'min-w',
  'min-height': 'min-h',
  'letter-spacing': 'tracking',
  flex: 'shorthand-flex',
  'flex-grow': 'grow',
  'flex-shrink': 'shrink',
  'flex-basis': 'basis',
  background: 'shorthand-background',
  animation: 'shorthand-animation',
  'animation-duration': 'duration',
  'animation-delay': 'delay',
  'animation-name': 'animate',
  transition: 'shorthand-transition',
  'transition-duration': 'duration',
  'transition-property': 'transition',
  font: 'shorthand-font',
  'line-height': 'leading',
  'z-index': 'z',
  'list-style': 'shorthand-list-style',
  'background-image': 'bg',
  content: 'content',
  // transform: 'shorthand-transform',
  'list-style-image': 'list-image',
  'font-weight': {
    100: 'font-thin',
    200: 'font-extra-light',
    300: 'font-light',
    400: 'font-normal',
    500: 'font-medium',
    600: 'font-semibold',
    700: 'font-bold',
    800: 'font-extrabold',
    900: 'font-black'
  },
  position: {
    "static": 'static',
    absolute: 'absolute',
    relative: 'relative',
    sticky: 'sticky',
    fixed: 'fixed'
  },
  cursor: {
    auto: 'cursor-auto',
    "default": 'cursor-default',
    pointer: 'cursor-pointer',
    wait: 'cursor-wait',
    text: 'cursor-text',
    move: 'cursor-move',
    help: 'cursor-help',
    'not-allowed': 'cursor-not-allowed'
  },
  display: {
    block: 'block',
    'inline-block': 'inline-block',
    inline: 'inline',
    flex: 'flex',
    'inline-flex': 'inline-flex',
    table: 'table',
    'inline-table': 'inline-table',
    'table-caption': 'table-caption',
    'table-cell': 'table-cell',
    'table-column': 'table-column',
    'table-column-group': 'table-column-group',
    'table-footer-group': 'table-footer-group',
    'table-header-group': 'table-header-group',
    'table-row-group': 'table-row-group',
    'table-row': 'table-row',
    'flow-root': 'flow-root',
    grid: 'grid',
    'inline-grid': 'inline-grid',
    contents: 'contents',
    'list-item': 'list-item',
    none: 'hidden'
  },
  "float": {
    right: 'float-right',
    left: 'float-left',
    none: 'float-none'
  },
  'justify-content': {
    'flex-start': 'justify-start',
    'flex-end': 'justify-end',
    center: 'justify-center',
    'space-between': 'justify-between',
    'space-around': 'justify-around',
    'space-evenly': 'justify-evenly'
  },
  'align-items': {
    'flex-start': 'items-start',
    'flex-end': 'items-end',
    center: 'items-center',
    baseline: 'items-baseline',
    stretch: 'items-stretch'
  },
  'flex-direction': {
    row: 'flex-row',
    'row-reverse': 'flex-row-reverse',
    column: 'flex-col',
    'column-reverse': 'flex-col-reverse'
  },
  'box-sizing': {
    'border-box': 'box-border',
    'content-box': 'box-content'
  },
  'white-space': {
    normal: 'whitespace-normal',
    nowrap: 'whitespace-nowrap',
    pre: 'whitespace-pre',
    'pre-line': 'whitespace-pre-line',
    'pre-wrap': 'whitespace-pre-wrap'
  },
  overflow: {
    auto: 'overflow-auto',
    hidden: 'overflow-hidden',
    visible: 'overflow-visible',
    scroll: 'overflow-scroll'
  },
  'overflow-x': {
    auto: 'overflow-x-auto',
    hidden: 'overflow-x-hidden',
    visible: 'overflow-x-visible',
    scroll: 'overflow-x-scroll'
  },
  'overflow-y': {
    auto: 'overflow-y-auto',
    hidden: 'overflow-y-hidden',
    visible: 'overflow-y-visible',
    scroll: 'overflow-y-scroll'
  },
  visibility: {
    visible: 'visible',
    hidden: 'invisible',
    collapse: 'collapse'
  },
  'text-align': {
    left: 'text-left',
    center: 'text-center',
    right: 'text-right',
    justify: 'text-justify'
  },
  'background-position': {
    bottom: 'bg-bottom',
    center: 'bg-center',
    left: 'bg-left',
    'left bottom': 'bg-left-bottom',
    'left top': 'bg-left-top',
    right: 'bg-right',
    'right bottom': 'bg-right-bottom',
    'right top': 'bg-right-top',
    top: 'bg-top'
  },
  'background-repeat': {
    repeat: 'bg-repeat',
    'no-repeat': 'bg-no-repeat',
    'repeat-x': 'bg-repeat-x',
    'repeat-y': 'bg-repeat-y',
    round: 'bg-repeat-round',
    space: 'bg-repeat-space'
  },
  'background-size': {
    auto: 'bg-auto',
    cover: 'bg-cover',
    contain: 'bg-contain'
  },
  'text-decoration': {
    underline: 'underline',
    'line-through': 'line-througn',
    none: 'no-underline'
  }
}, _defineProperty(_stylesMap, "border-style", {
  solid: 'border-solid',
  dashed: 'border-dashed',
  dotted: 'border-dotted',
  "double": 'border-double',
  hidden: 'border-hidden',
  none: 'border-none'
}), _defineProperty(_stylesMap, 'vertical-align', {
  baseline: 'align-baseline',
  top: 'align-top',
  middle: 'align-middle',
  bottom: 'align-bottom',
  'text-top': 'align-text-top',
  'text-bottom': 'align-text-bottom',
  sub: 'align-sub',
  "super": 'align-super'
}), _defineProperty(_stylesMap, 'font-variant-numeric', {
  normal: 'normal-nums',
  ordinal: 'ordinal',
  'slashed-zero': 'slashed-zero',
  'lining-nums': 'lining-nums',
  'oldstyle-nums': 'oldstyle-nums',
  'proportional-nums': 'proportional-nums',
  'tabular-nums': 'tabular-nums',
  'diagonal-fractions': 'diagonal-fractions',
  'stacked-fractions': 'stacked-fractions'
}), _defineProperty(_stylesMap, 'list-style-type', {
  none: 'list-none',
  disc: 'list-disc',
  decimal: 'list-decimal'
}), _defineProperty(_stylesMap, 'list-style-position', {
  inside: 'list-inside',
  outside: 'list-outside'
}), _defineProperty(_stylesMap, 'font-style', {
  italic: 'italic',
  normal: 'not-italic'
}), _defineProperty(_stylesMap, "background-size", {
  auto: 'bg-auto',
  cover: 'bg-cover',
  contain: 'bg-contain'
}), _defineProperty(_stylesMap, "background-repeat", {
  repeat: 'bg-repeat',
  'no-repeat': 'bg-no-repeat',
  'repeat-x': 'bg-repeat-x',
  'repeat-y': 'bg-repeat-y',
  round: 'bg-repeat-round',
  space: 'bg-repeat-space'
}), _defineProperty(_stylesMap, "background-position", {
  top: 'bg-top',
  right: 'bg-right',
  bottom: 'bg-bottom',
  left: 'bg-left',
  center: 'bg-center',
  'left bottom': 'bg-left-bottom',
  'left top': 'bg-left-top',
  'right bottom': 'bg-right-bottom',
  'right top': 'bg-right-top'
}), _defineProperty(_stylesMap, 'background-origin', {
  'border-box': 'bg-origin-border',
  'padding-box': 'bg-origin-padding',
  'content-box': 'bg-origin-content'
}), _defineProperty(_stylesMap, 'background-clip', {
  'border-box': 'bg-clip-border',
  'padding-box': 'bg-clip-padding',
  'content-box': 'bg-clip-content',
  text: 'bg-clip-text'
}), _defineProperty(_stylesMap, 'background-attachment', {
  fixed: 'bg-fixed',
  local: 'bg-local',
  scroll: 'bg-scroll'
}), _defineProperty(_stylesMap, 'transform-origin', {
  top: 'origin-top',
  right: 'origin-right',
  bottom: 'origin-bottom',
  left: 'origin-left',
  center: 'origin-center',
  'top right': 'origin-top-right',
  'top left': 'origin-top-left',
  'bottom right': 'origin-bottom-right',
  'bottom left': 'origin-bottom-left'
}), _defineProperty(_stylesMap, 'flex-wrap', {
  wrap: 'flex-wrap',
  'wrap-reverse': 'flex-wrap-reverse',
  nowrap: 'flex-nowrap'
}), _stylesMap);
var stylesMap_1 = stylesMap$2;

var unsupportedPseudoClasses$2 = {
  link: null
};
var unsupportedPseudoClass = unsupportedPseudoClasses$2;

var stylesMap$1 = stylesMap_1;
var unsupportedPseudoClasses$1 = unsupportedPseudoClass;
var _const = {
  stylesMap: stylesMap$1,
  unsupportedPseudoClasses: unsupportedPseudoClasses$1
};

var spec = require$$0$1;
var shorthandParser = require$$1;
var filterNodes = filterNodes_1;
var deepClone = utils.deepClone;
var stylesMap = _const.stylesMap,
  unsupportedPseudoClasses = _const.unsupportedPseudoClasses;
var rawCssCollector = function rawCssCollector(mediaPrefix, rawCss, selector, prop, value) {
  // '342:.download__dialog': { transform: 'translateY(-50%)' }
  rawCss[mediaPrefix + selector] = rawCss[mediaPrefix + selector] || {};
  rawCss[mediaPrefix + selector][prop] = value;
};
var pseudoPrefixParser = function pseudoPrefixParser(mediaPrefix, rawCss, selector, prop, value) {
  var prefixs = [];
  var segments = selector.split(',');
  var _loop = function _loop() {
    var segment = segments[i];
    segment.replace(/:([a-z]+)/g, function (_, pseudoClass) {
      if (unsupportedPseudoClasses.hasOwnProperty(pseudoClass)) {
        rawCssCollector(mediaPrefix, rawCss, segment, prop, value);
      } else {
        prefixs.push("".concat(pseudoClass, ":"));
      }
    });
  };
  for (var i = 0, l = segments.length; i < l; i++) {
    _loop();
  }
  return prefixs.length ? prefixs : [''];
};
var strategies = {
  translateX: function translateX(exprPrefix, value, pseudoPrefixs, mediaPrefix) {
    var tailwindExp = '';
    var negativePrefix = '';
    if (value.startsWith('-')) {
      value = value.slice(1);
      negativePrefix = '-';
    }
    for (var i = 0, l = pseudoPrefixs.length; i < l; i++) {
      tailwindExp += "".concat(mediaPrefix).concat(pseudoPrefixs[i]).concat(negativePrefix).concat(exprPrefix, "-[").concat([value], "] ");
    }
    return tailwindExp;
  }
};
strategies.translateY = strategies.scaleX = strategies.scaleY = strategies.translateX;
var styleToTailwind = function styleToTailwind(selector, prop, value, specificity, classMetadata, rawCss, mediaPrefix) {
  // shorthand parser convert `transform: translate(50%); ` to
  // `{ translateX: 50%, translateY: 50% }`, styles map don't support
  // `translate[X|Y]?`, but support transform: `translate[X|Y]?`
  var strategy = strategies[prop];
  var exprOrKeywordValues = stylesMap[prop];
  if (exprOrKeywordValues || strategy) {
    if (value.includes('data:')) {
      value = value.replace(/my-semicolon/g, ';');
      rawCssCollector(mediaPrefix, rawCss, selector, prop, value);
      return;
    }
    var tailwindExp = '';
    var _exprOrKeywordValues = stylesMap[prop];
    var isKeywordValues = _typeof(_exprOrKeywordValues) === 'object';
    var pseudoPrefixs = pseudoPrefixParser(mediaPrefix, rawCss, selector, prop, value);
    if (isKeywordValues) {
      var keywordValue = _exprOrKeywordValues[value];
      if (keywordValue) {
        // position: absolute; -> absolute 
        for (var i = 0, l = pseudoPrefixs.length; i < l; i++) {
          tailwindExp += "".concat(mediaPrefix).concat(pseudoPrefixs[i]).concat(_exprOrKeywordValues[value], " ");
        }
      } else {
        rawCssCollector(mediaPrefix, rawCss, selector, prop, value);
      }
    } else {
      // try parse shorthand property
      var res = shorthandParser(prop, value);
      if (res) {
        var props = Object.keys(res);
        for (var _i = 0, _l = props.length; _i < _l; _i++) {
          var _prop = props[_i];
          var _value = res[_prop];
          if (_value !== 'unset') {
            styleToTailwind(selector, _prop, _value, specificity, classMetadata, rawCss, mediaPrefix);
          }
        }
      } else {
        if (strategy) {
          var exprPrefix1 = prop.match(/[a-z]+/)[0]; // translate
          var exprPrefix2 = prop.match(/[A-Z]+/)[0].toLowerCase(); // X
          var exprPrefix = "".concat(exprPrefix1, "-").concat(exprPrefix2); // translate-X

          tailwindExp += strategy(exprPrefix, value, pseudoPrefixs, mediaPrefix);
        } else {
          if (prop === 'content') {
            for (var _i2 = 0, _l2 = pseudoPrefixs.length; _i2 < _l2; _i2++) {
              var content = value.match(/['"](.*?)['"]/)[1];
              if (content) {
                for (var _i3 = 0, _l3 = pseudoPrefixs.length; _i3 < _l3; _i3++) {
                  tailwindExp += "".concat(mediaPrefix).concat(pseudoPrefixs[_i3], "content-['").concat(content, "'] ");
                }
              }
            }
          } else {
            // width: 9999px; -> w-[9999px]
            for (var _i4 = 0, _l4 = pseudoPrefixs.length; _i4 < _l4; _i4++) {
              tailwindExp += "".concat(mediaPrefix).concat(pseudoPrefixs[_i4]).concat(_exprOrKeywordValues, "-[").concat(value, "] ");
            }
          }
        }
      }
    }
    tailwindExp = tailwindExp.slice(0, -1);
    classMetadata[mediaPrefix + prop] = {
      tailwindExp: tailwindExp,
      specificity: specificity
    };
  } else {
    rawCssCollector(mediaPrefix, rawCss, selector, prop, value);
  }
};
var cssStyleRuleRegexp = /}?(.*?){(.*?)}/g;
var cssToMetadata$2 = function cssToMetadata() {
  var mediaPrefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var css = arguments.length > 1 ? arguments[1] : undefined;
  var sourceNodes = arguments.length > 2 ? arguments[2] : undefined;
  var isInject = arguments.length > 3 ? arguments[3] : undefined;
  var rawCss = arguments.length > 4 ? arguments[4] : undefined;
  var classMetadataList = arguments.length > 5 ? arguments[5] : undefined;
  css.replace(cssStyleRuleRegexp, function (_, selector, cssText) {
    // empty rule -> .foo {}
    if (!cssText) {
      return;
    }
    if (isInject) {
      var nodes = filterNodes(sourceNodes, selector);
      if (nodes.length) {
        var specificity = spec.getSpecificity(selector);
        var classMetadata = {};
        cssText.replace(/(.*?):([^;]*);?/g, function (_, prop, value) {
          styleToTailwind(selector, prop, value, specificity, classMetadata, rawCss, mediaPrefix);
        });
        for (var i = 0, l = nodes.length; i < l; i++) {
          var _classMetadata = deepClone(classMetadata);
          var node = nodes[i];
          var source = node.classMetadata;
          if (!source) {
            node.classMetadata = _classMetadata;
          } else {
            for (var key in _classMetadata) {
              var value = _classMetadata[key];
              if (!source[key] || source[key].specificity <= value.specificity) {
                source[key] = value;
              }
            }
          }
        }
      }
    } else {
      var _classMetadata2 = {};
      var _specificity = spec.getSpecificity(selector);
      cssText.replace(/(.*?):([^;]*);?/g, function (_, prop, value) {
        styleToTailwind(selector, prop, value, _specificity, _classMetadata2, rawCss, mediaPrefix);
      });
      var _classMetadata3 = deepClone(_classMetadata2);
      var _source = classMetadataList[selector];
      if (!_source) {
        classMetadataList[selector] = _classMetadata3;
      } else {
        for (var _key in _classMetadata3) {
          var _value2 = _classMetadata3[_key];
          if (!_source[_key] || _source[_key].specificity <= _value2.specificity) {
            _source[_key] = _value2;
          }
        }
      }
    }
  });

  // if (isInject) {
  //   for (let i = 0, l = sourceNodes.length; i < l; i++) {
  //     const node = sourceNodes[i]
  //     const { classMetadata, attrs } = node

  //     if (classMetadata) {
  //       node.tailwindExp = classMetadataToTailwindExp(classMetadata, attrs.rawClass, isInject)
  //     }
  //   }
  // } else {
  //   const selectors = Object.keys(res)

  //   for (let i = 0, l = selectors.length; i < l; i++) {
  //     const selector = selectors[i]
  //     const classMetadata = res[selector]

  //     if (Object.keys(classMetadata).length ) {
  //       const newExpr = expr[selector] ? true : false
  //       let _expr = classMetadataToTailwindExp(
  //         classMetadata, selector, isInject, newExpr
  //       )

  //       res[selector].tailwindExp = _expr
  //       expr[selector] = expr[selector] || ''
  //       expr[selector] += _expr
  //     }
  //   }
  // }
};

var cssToMetadata_1 = cssToMetadata$2;

var metadataToExpr$1 = function metadataToExpr(classMetadataList) {
  var expr = '';
  var selectors = Object.keys(classMetadataList);
  for (var i = 0, l = selectors.length; i < l; i++) {
    var helper = '';
    var selector = selectors[i];
    var metadata = classMetadataList[selector];
    for (var key in metadata) {
      helper += "".concat(metadata[key].tailwindExp, " ");
    }

    // empty expr
    if (/^\s*$/.test(helper)) {
      continue;
    }
    expr += "".concat(selector, " {\r\n\t@apply ").concat(helper, "\r\n}\r\n\r\n");
  }
  return expr;
};
var metadataToExpr_1 = metadataToExpr$1;

var regexp$1 = /@keyframes\s([^{]+)\{(?:(?!\}\s*\})[\s\S])*\}\}/gi;
var parseKeyframes$2 = function parseKeyframes(css) {
  css = css.replace(regexp$1, function (_, $1) {
    return '';
  });
  return css;
};
var parseKeyframes_1 = parseKeyframes$2;

var cssToMetadata$1 = cssToMetadata_1;
var regexp = /@media\((.*?):(.*?)\){((?:(?!}}).)+)/g;
var parseMediaQuery$2 = function parseMediaQuery(rawCss, classMetadataList, css, sourceNode, isInject) {
  var breakPoints = {
    'min-width': [],
    'max-width': [],
    'min-height': [],
    'max-height': []
  };
  css = css.replace(regexp, function (_, p, v, cssText) {
    breakPoints[p].push({
      size: parseInt(v),
      cssText: "".concat(cssText, "}")
    });
    return '';
  });
  var props = Object.keys(breakPoints);
  for (var i = 0, l = props.length; i < l; i++) {
    var prop = props[i];
    if (prop.startsWith('max')) {
      breakPoints[prop].sort(function (a, b) {
        return b.size - a.size;
      });
    } else {
      breakPoints[prop].sort(function (a, b) {
        return a.size - b.size;
      });
    }
  }
  var maxWidthList = breakPoints['max-width'];
  for (var _i = 0, _l = maxWidthList.length; _i < _l; _i++) {
    var _maxWidthList$_i = maxWidthList[_i],
      size = _maxWidthList$_i.size,
      cssText = _maxWidthList$_i.cssText;
    cssToMetadata$1("".concat(size, ":"), cssText, sourceNode, isInject, rawCss, classMetadataList);
  }
  return css;
};
var parseMediaQuery_1 = parseMediaQuery$2;

var parseKeyframes$1 = parseKeyframes_1;
var parseMediaQuery$1 = parseMediaQuery_1;
var parser = {
  parseKeyframes: parseKeyframes$1,
  parseMediaQuery: parseMediaQuery$1
};

var HTML = require$$0$2;
var writeFile = require$$0.promises.writeFile;
var purifier = purifier_1;
var fallback = fallback_1;
var cssToMetadata = cssToMetadata_1;
var metadataToExpr = metadataToExpr_1;
var parseKeyframes = parser.parseKeyframes,
  parseMediaQuery = parser.parseMediaQuery;
var importTailwind = function importTailwind(ast) {
  ast.children[0].children[0].children.push({
    type: 'tag',
    attrs: {
      src: 'https://cdn.tailwindcss.com'
    },
    parent: ast.children[0].children[0],
    tagName: 'script',
    children: []
  });
};

var toTailwind = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(htmlInput, cssInput, output) {
    var isInject,
      _yield$purifier,
      html,
      css,
      _HTML$parse,
      ast,
      sourceNodes,
      rawCss,
      classMetadataList,
      res,
      expr,
      _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          isInject = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;
          _context.next = 3;
          return purifier(htmlInput, cssInput);
        case 3:
          _yield$purifier = _context.sent;
          html = _yield$purifier.html;
          css = _yield$purifier.css;
          _HTML$parse = HTML.parse(html), ast = _HTML$parse.ast, sourceNodes = _HTML$parse.nodes;
          rawCss = {};
          classMetadataList = {};
          css = parseKeyframes(css);
          css = parseMediaQuery(rawCss, classMetadataList, css, sourceNodes, isInject);
          cssToMetadata('', css, sourceNodes, isInject, rawCss, classMetadataList);
          if (!isInject) {
            _context.next = 19;
            break;
          }
          importTailwind(ast);
          res = HTML.stringify(ast);
          _context.next = 17;
          return writeFile("".concat(output, "/index.html"), res);
        case 17:
          _context.next = 22;
          break;
        case 19:
          expr = metadataToExpr(classMetadataList);
          _context.next = 22;
          return writeFile("".concat(output, "/index.css"), expr);
        case 22:
          if (!Object.keys(rawCss).length) {
            _context.next = 25;
            break;
          }
          _context.next = 25;
          return fallback(rawCss, output);
        case 25:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function toTailwind(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
var src = toTailwind;

module.exports = src;
