'use strict';

var require$$0 = require('selector-specificity');
var require$$2 = require('fs');
var require$$1 = require('css-shorthand-parser');

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var selfClosingTags$2 = {
  area: null,
  base: null,
  br: null,
  col: null,
  embed: null,
  hr: null,
  img: null,
  input: null,
  link: null,
  meta: null,
  param: null,
  source: null,
  track: null,
  wbr: null
};
var selfClosingTags_1 = selfClosingTags$2;

var selfClosingTags$1 = selfClosingTags_1;
var regexp = /<[\s\S]*?>[^<]*/g;
var documentType = '<!DOCTYPE html>';
var parse$1 = function parse(html) {
  html = html.trim();
  if (html.startsWith(documentType)) {
    html = html.slice(documentType.length);
  }
  var ast = {
    type: 'root',
    attrs: {},
    parent: null,
    tagName: null,
    children: []
  };
  var matched = html.match(regexp);
  var nodes = [];
  var parent = ast;
  var _loop = function _loop() {
    // <html lang="en">
    // <input foo="bar" />
    // <title>Document
    // <div foo="bar">foo
    // </div>
    var m = matched[i].trim();
    if (!m.startsWith('</')) {
      // <html lang="en"> -> html lang="en">
      m = m.slice(1);
      var tagName = m.match(/[^\s>]*/)[0];
      var attrs = {};
      var node = {
        type: 'tag',
        attrs: attrs,
        parent: parent,
        tagName: tagName,
        children: []
      };

      // div foo="bar">foo -> foo="bar">foo
      // html lang="en"> -> lang="en">
      // title>Document -> >Document
      m = m.slice(tagName.length).trimStart();
      if (m !== '>') {
        // >Document
        if (m.startsWith('>')) {
          node.children.push({
            type: 'text',
            text: m.slice(1).trimStart()
          });
        } else {
          // lang="en">
          // foo="bar">foo
          m.replace(/\s*(.*?)=['"]\s*([\s\S]*?)\s*['"]/g, function (_, attr, value) {
            var formattedValue = {};
            if (attr === 'style') {
              value.replace(/\s*(.*?)\s*:\s*(.*?)\s*[;]/g, function (_, styleName, styleValue) {
                formattedValue[styleName] = styleValue;
              });
            } else if (attr === 'class') {
              var segments = value.split(/\s+/);
              for (var _i = 0, _l = segments.length; _i < _l; _i++) {
                formattedValue[segments[_i]] = null;
              }
            }
            attrs[attr] = Object.keys(formattedValue).length ? formattedValue : value;
          });
          var text = m.match(/>([\s\S]*)/)[1];
          if (text) {
            node.children.push({
              type: 'text',
              text: text
            });
          }
        }
      }
      parent.children.push(node);
      nodes.push(node);
      if (!selfClosingTags$1.hasOwnProperty(tagName)) {
        parent = node;
      }
    } else {
      parent = parent.parent;
    }
  };
  for (var i = 0, l = matched.length; i < l; i++) {
    _loop();
  }
  return {
    ast: ast,
    nodes: nodes
  };
};
var parse_1 = parse$1;

var selfClosingTags = selfClosingTags_1;
var genElement = function genElement(node) {
  var res = '';
  var attrs = node.attrs,
    tagName = node.tagName,
    children = node.children,
    tailwindExp = node.tailwindExp;
  var keys = Object.keys(attrs);
  var _attrs = keys.length || tailwindExp ? " ".concat(genAttrs(attrs, keys, tailwindExp)) : '';
  res += "<".concat(tagName).concat(_attrs, ">");
  if (!selfClosingTags.hasOwnProperty(tagName)) {
    var _children = children.length ? stringify$1(node) : '';
    res += "".concat(_children, "</").concat(tagName, ">");
  }
  return res;
};
var genText = function genText(node) {
  return node.text;
};
var genAttrs = function genAttrs(attrs, keys, tailwindExp) {
  var res = '';
  for (var i = 0, l = keys.length; i < l; i++) {
    var attr = keys[i];
    var value = attrs[attr];
    if (attr !== 'class') {
      res += "".concat(attr, "=\"").concat(value, "\" ");
    }
  }
  if (tailwindExp) {
    // don't add tailwind expression by attr.class because element selector.
    // TODO: don't remove source class name
    res += "class=\"".concat(tailwindExp, "\"");
  }
  return res;
};
var stringify$1 = function stringify(ast) {
  var html = '';
  var nodes = ast.children;
  for (var i = 0, l = nodes.length; i < l; i++) {
    var node = nodes[i];
    if (node.type === 'tag') {
      html += genElement(node);
    } else {
      html += genText(node);
    }
  }
  return html;
};
var stringify_1 = stringify$1;

var parse = parse_1;
var stringify = stringify_1;
var HTML$1 = {
  parse: parse,
  stringify: stringify
};
var htmlParser = HTML$1;

var deepClone$2 = function deepClone(o) {
  return JSON.parse(JSON.stringify(o));
};
var deepClone_1 = deepClone$2;

var spec$1 = require$$0;
var strategies = {
  id: function id(nodes, name) {
    return nodes.filter(function (node) {
      return node.attrs.id === name;
    });
  },
  "class": function _class(nodes, name) {
    return nodes.filter(function (node) {
      var _node$attrs, _node$attrs$class;
      return (_node$attrs = node.attrs) === null || _node$attrs === void 0 ? void 0 : (_node$attrs$class = _node$attrs["class"]) === null || _node$attrs$class === void 0 ? void 0 : _node$attrs$class.hasOwnProperty(name);
    });
  },
  attribute: function attribute(nodes, name, value) {
    return nodes.filter(function (node) {
      return node.attrs[name] === value;
    });
  },
  universal: function universal(nodes) {
    return nodes;
  },
  // type selector
  element: function element(nodes, name) {
    return nodes.filter(function (node) {
      return node.tagName === name;
    });
  },
  child: function child(nodes) {
    var res = [];
    for (var i = 0, l = nodes.length; i < l; i++) {
      Array.prototype.push.apply(res, nodes[i].children);
    }
    return res;
  },
  sibling: function sibling(nodes) {
    var res = [];
    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = nodes[i];
      var children = node.parent.children;
      var index = children.indexOf(node);
      for (var _i = index + 1, _l = children.length; _i < _l; _i++) {
        res.push(children[_i]);
      }
    }
    return res;
  },
  descendant: function descendant(nodes) {
    var res = [];
    var getDescendantNodes = function getDescendantNodes(res, nodes) {
      for (var i = 0, l = nodes.length; i < l; i++) {
        var node = nodes[i];
        var type = node.type;
        if (type === 'text') {
          continue;
        }
        res.push(node);
        var children = node.children;
        if (children.length) {
          getDescendantNodes(res, children);
        }
      }
    };
    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = nodes[i];
      getDescendantNodes(res, node.children);
    }
    return res;
  },
  adjacent: function adjacent(nodes) {
    var res = [];
    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = nodes[i];
      var children = node.parent.children;
      var index = children.indexOf(node);
      var adjacentNode = children[index + 1];
      adjacentNode && res.push(adjacentNode);
    }
    return res;
  },
  'pseudo-class': function pseudoClass(nodes, name, value) {
    var strategy = pseudoClassStrategies[name];
    if (strategy) {
      return strategy(nodes, value);
    }
    return nodes;
  },
  'pseudo-element': function pseudoElement() {}
};
var pseudoClassStrategies = {
  'first-of-type': function firstOfType(nodes) {
    return [nodes[0]];
  },
  'last-of-type': function lastOfType(nodes) {
    return [nodes[nodes.length - 1]];
  }
};
var filterNodes$2 = function filterNodes(sourceNodes, selector) {
  var nodes = sourceNodes;
  var selectorNodes = spec$1.getNodes(selector);
  for (var i = 0, l = selectorNodes.length; i < l; i++) {
    var selectorNode = selectorNodes[i];
    var type = selectorNode.type,
      name = selectorNode.name,
      value = selectorNode.value;

    // .footer a:link,.footer a:visited
    if (type === 'combine') {
      var index = selector.indexOf(',');

      // remove duplicated node
      nodes = _toConsumableArray(new Set([].concat(_toConsumableArray(nodes), _toConsumableArray(filterNodes(sourceNodes, selector.slice(index + 1))))));
      break;
    }
    nodes = strategies[type](nodes, name, value, selectorNode) || [];
    if (!nodes.length) {
      break;
    }
  }
  return nodes;
};
var filterNodes_1 = filterNodes$2;

var _stylesMap;
var stylesMap$2 = (_stylesMap = {
  width: 'w',
  height: 'h',
  opacity: 'opacity',
  padding: 'shorthand-padding',
  'padding-top': 'pt',
  'padding-right': 'pr',
  'padding-bottom': 'pb',
  'padding-left': 'pl',
  margin: 'shorthand-margin',
  'margin-top': 'mt',
  'margin-right': 'mr',
  'margin-bottom': 'mb',
  'margin-left': 'ml',
  top: 't',
  right: 'r',
  bottom: 'b',
  left: 'l',
  border: 'shorthand-border',
  'border-radius': 'rounded',
  'border-width': 'shorthand-border-width',
  'border-top-width': 'border-t',
  'border-right-width': 'border-r',
  'border-bottom-width': 'border-b',
  'border-left-width': 'border-l',
  'border-color': 'shorthand-border-color',
  'border-top-color': 'border-t',
  'border-right-color': 'border-r',
  'border-bottom-color': 'border-b',
  'border-left-color': 'border-l',
  'border-style': 'shorthand-border-style',
  'border-top-style': 'border-t',
  'border-right-style': 'border-r',
  'border-bottom-style': 'border-b',
  'border-left-style': 'border-l',
  'border-top': 'shorthand-border-top',
  'border-right': 'shorthand-border-right',
  'border-bottom': 'shorthand-border-bottom',
  'border-left': 'shorthand-border-left',
  color: 'text',
  'font-size': 'text',
  'font-family': 'font',
  'background-color': 'bg',
  'min-width': 'min-w',
  'flex': 'shorthand-flex',
  'flex-grow': 'flex-grow',
  'flex-shrink': 'flex-shrink',
  'flex-basis': 'flex-basis',
  'background': 'shorthand-background',
  'animation': 'shorthand-animation',
  'animation-duration': 'duration',
  'animation-name': 'animate',
  'transition': 'shorthand-transition',
  'transition-duration': 'duration',
  'transition-property': 'transition',
  'font': 'shorthand-font',
  'line-height': 'leading',
  'flex-wrap': 'wrap',
  'z-index': 'z',
  'list-style-image': 'list-image',
  'list-style': 'shorthand-list-style',
  'background-image': 'bg',
  'content': 'content',
  'font-weight': {
    100: 'font-thin',
    200: 'font-extra-light',
    300: 'font-light',
    400: 'font-normal',
    500: 'font-medium',
    600: 'font-semibold',
    700: 'font-bold',
    800: 'font-extrabold',
    900: 'font-black'
  },
  position: {
    "static": 'static',
    absolute: 'absolute',
    relative: 'relative',
    sticky: 'sticky',
    fixed: 'fixed'
  },
  cursor: {
    auto: 'cursor-auto',
    "default": 'cursor-default',
    pointer: 'cursor-pointer',
    wait: 'cursor-wait',
    text: 'cursor-text',
    move: 'cursor-move',
    help: 'cursor-help',
    'not-allowed': 'cursor-not-allowed'
  },
  display: {
    block: 'block',
    'inline-block': 'inline-block',
    inline: 'inline',
    flex: 'flex',
    'inline-flex': 'inline-flex',
    table: 'table',
    'inline-table': 'inline-table',
    'table-caption': 'table-caption',
    'table-cell': 'table-cell',
    'table-column': 'table-column',
    'table-column-group': 'table-column-group',
    'table-footer-group': 'table-footer-group',
    'table-header-group': 'table-header-group',
    'table-row-group': 'table-row-group',
    'table-row': 'table-row',
    'flow-root': 'flow-root',
    grid: 'grid',
    'inline-grid': 'inline-grid',
    contents: 'contents',
    'list-item': 'list-item',
    hidden: 'none'
  },
  "float": {
    right: 'float-right',
    left: 'float-left',
    none: 'float-none'
  },
  'justify-content': {
    'flex-start': 'justify-start',
    'flex-end': 'justify-end',
    center: 'justify-center',
    'space-between': 'justify-between',
    'space-around': 'justify-around',
    'space-evenly': 'justify-evenly'
  },
  'align-items': {
    'flex-start': 'items-start',
    'flex-end': 'items-end',
    center: 'items-center',
    baseline: 'items-baseline',
    stretch: 'items-stretch'
  },
  'flex-direction': {
    row: 'flex-row',
    'row-reverse': 'flex-row-reverse',
    column: 'flex-col',
    'column-reverse': 'flex-col-reverse'
  },
  'box-sizing': {
    'border-box': 'box-border',
    'content-box': 'box-content'
  },
  'white-space': {
    normal: 'white-space-normal',
    nowrap: 'white-space-nowrap',
    pre: 'white-space-pre',
    'pre-line': 'white-space-pre-line',
    'pre-wrap': 'white-space-pre-wrap'
  },
  overflow: {
    auto: 'overflow-auto',
    hidden: 'overflow-hidden',
    visible: 'overflow-visible',
    scroll: 'overflow-scroll'
  },
  'overflow-x': {
    auto: 'overflow-x-auto',
    hidden: 'overflow-x-hidden',
    visible: 'overflow-x-visible',
    scroll: 'overflow-x-scroll'
  },
  'overflow-y': {
    auto: 'overflow-y-auto',
    hidden: 'overflow-y-hidden',
    visible: 'overflow-y-visible',
    scroll: 'overflow-y-scroll'
  },
  visibility: {
    visible: 'visible',
    hidden: 'invisible',
    collapse: 'collapse'
  },
  'text-align': {
    left: 'text-left',
    center: 'text-center',
    right: 'text-right',
    justify: 'text-justify'
  },
  'background-position': {
    bottom: 'bg-bottom',
    center: 'bg-center',
    left: 'bg-left',
    'left bottom': 'bg-left-bottom',
    'left top': 'bg-left-top',
    right: 'bg-right',
    'right bottom': 'bg-right-bottom',
    'right top': 'bg-right-top',
    top: 'bg-top'
  },
  'background-repeat': {
    repeat: 'bg-repeat',
    'no-repeat': 'bg-no-repeat',
    'repeat-x': 'bg-repeat-x',
    'repeat-y': 'bg-repeat-y',
    round: 'bg-repeat-round',
    space: 'bg-repeat-space'
  },
  'background-size': {
    auto: 'bg-auto',
    cover: 'bg-cover',
    contain: 'bg-contain'
  },
  'text-decoration': {
    underline: 'underline',
    'line-through': 'line-througn',
    none: 'no-underline'
  }
}, _defineProperty(_stylesMap, "border-style", {
  solid: 'border-solid',
  dashed: 'border-dashed',
  dotted: 'border-dotted',
  "double": 'border-double',
  hidden: 'border-hidden',
  none: 'border-none'
}), _defineProperty(_stylesMap, 'vertical-align', {
  baseline: 'align-baseline',
  top: 'align-top',
  middle: 'align-middle',
  bottom: 'align-bottom',
  'text-top': 'align-text-top',
  'text-bottom': 'align-text-bottom',
  sub: 'align-sub',
  "super": 'align-super'
}), _defineProperty(_stylesMap, 'font-variant-numeric', {
  normal: 'normal-nums',
  ordinal: 'ordinal',
  'slashed-zero': 'slashed-zero',
  'lining-nums': 'lining-nums',
  'oldstyle-nums': 'oldstyle-nums',
  'proportional-nums': 'proportional-nums',
  'tabular-nums': 'tabular-nums',
  'diagonal-fractions': 'diagonal-fractions',
  'stacked-fractions': 'stacked-fractions'
}), _defineProperty(_stylesMap, 'list-style-type', {
  none: 'list-none',
  disc: 'list-disc',
  decimal: 'list-decimal'
}), _defineProperty(_stylesMap, 'list-style-position', {
  inside: 'list-inside',
  outside: 'list-outside'
}), _defineProperty(_stylesMap, 'font-style', {
  italic: 'italic',
  normal: 'not-italic'
}), _defineProperty(_stylesMap, "background-size", {
  auto: 'bg-auto',
  cover: 'bg-cover',
  contain: 'bg-contain'
}), _defineProperty(_stylesMap, "background-repeat", {
  repeat: 'bg-repeat',
  'no-repeat': 'bg-no-repeat',
  'repeat-x': 'bg-repeat-x',
  'repeat-y': 'bg-repeat-y',
  round: 'bg-repeat-round',
  space: 'bg-repeat-space'
}), _defineProperty(_stylesMap, "background-position", {
  top: 'bg-top',
  right: 'bg-right',
  bottom: 'bg-bottom',
  left: 'bg-left',
  center: 'bg-center',
  'left bottom': 'bg-left-bottom',
  'left top': 'bg-left-top',
  'right bottom': 'bg-right-bottom',
  'right top': 'bg-right-top'
}), _defineProperty(_stylesMap, 'background-origin', {
  'border-box': 'bg-origin-border',
  'padding-box': 'bg-origin-padding',
  'content-box': 'bg-origin-content'
}), _defineProperty(_stylesMap, 'background-clip', {
  'border-box': 'bg-clip-border',
  'padding-box': 'bg-clip-padding',
  'content-box': 'bg-clip-content',
  text: 'bg-clip-text'
}), _defineProperty(_stylesMap, 'background-attachment', {
  fixed: 'bg-fixed',
  local: 'bg-local',
  scroll: 'bg-scroll'
}), _defineProperty(_stylesMap, 'transform-origin', {
  top: 'origin-top',
  right: 'origin-right',
  bottom: 'origin-bottom',
  left: 'origin-left',
  center: 'origin-center',
  'top-right': 'origin-top-right',
  'top-left': 'origin-top-left',
  'bottom-right': 'origin-bottom-right',
  'bottom-left': 'origin-bottom-left'
}), _stylesMap);
var stylesMap_1 = stylesMap$2;

var stylesMap$1 = stylesMap_1;
var _const = {
  stylesMap: stylesMap$1
};

var stylesMap = _const.stylesMap;
var shorthandParser = require$$1;
var styleToTailwind$2 = function styleToTailwind(selector, prop, value, specificity, classMetadata) {
  var tailwindExp = '';
  var expOrMap = stylesMap[prop];
  if (expOrMap) {
    var isStaticValue = _typeof(expOrMap) === 'object';
    var key = isStaticValue ? prop : expOrMap;
    if (isStaticValue) {
      // position: absolute; -> absolute
      tailwindExp += "".concat(expOrMap[value]);
    } else {
      // width: 9999px; -> w-[9999px]
      value = String(value).replace(/\s{2,}/, ' ');
      var res = shorthandParser(prop, value);
      if (res) {
        var props = Object.keys(res);
        for (var i = 0, l = props.length; i < l; i++) {
          var _prop = props[i];
          var _value = res[_prop];
          if (_value !== 'unset') {
            styleToTailwind(selector, _prop, _value, specificity, classMetadata);
          }
        }
      } else {
        if (expOrMap === 'content') {
          var content = value.match(/['"](.*?)['"]/)[1];
          if (content) {
            var index = selector.lastIndexOf(':');
            var prefix = selector.slice(index + 1);
            tailwindExp += "".concat(prefix, ":").concat(expOrMap, "-['").concat(content, "']");
          }
        } else {
          tailwindExp += "".concat(expOrMap, "-[").concat(value, "]");
        }
      }
    }
    classMetadata[key] = {
      tailwindExp: tailwindExp,
      specificity: specificity
    };
  }
};
var styleToTailwind_1 = styleToTailwind$2;

var classMetadataToTailwindExp$2 = function classMetadataToTailwindExp(classMetadata) {
  var tailwindExp = '';
  for (var key in classMetadata) {
    tailwindExp += "".concat(classMetadata[key].tailwindExp, " ");
  }
  return tailwindExp.slice(0, -1);
};
var classMetadataToTailwindExp_1 = classMetadataToTailwindExp$2;

var deepClone$1 = deepClone_1;
var filterNodes$1 = filterNodes_1;
var styleToTailwind$1 = styleToTailwind_1;
var classMetadataToTailwindExp$1 = classMetadataToTailwindExp_1;
var utils = {
  deepClone: deepClone$1,
  filterNodes: filterNodes$1,
  styleToTailwind: styleToTailwind$1,
  classMetadataToTailwindExp: classMetadataToTailwindExp$1
};

var HTML = htmlParser;
var spec = require$$0;
var _require$$2$promises = require$$2.promises,
  readFile = _require$$2$promises.readFile,
  writeFile = _require$$2$promises.writeFile;
var deepClone = utils.deepClone,
  filterNodes = utils.filterNodes,
  styleToTailwind = utils.styleToTailwind,
  classMetadataToTailwindExp = utils.classMetadataToTailwindExp;
var cssStyleRuleRegexp = /}?\s*([\s\S]*?)\s*{\s*([\s\S]*?)\s*}/g;
var toTailwind = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(htmlInput, cssInput, output) {
    var css, html, _HTML$parse, ast, sourceNodes, i, l, node, classMetadata, res;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return readFile(cssInput, 'utf-8');
        case 2:
          css = _context.sent;
          _context.next = 5;
          return readFile(htmlInput, 'utf-8');
        case 5:
          html = _context.sent;
          // remove commented code
          css = css.replace(/\/\*[\s\S]*?\*\//g, '');
          html = html.replace(/<!--[\s\S]*?-->/g, '');
          _HTML$parse = HTML.parse(html), ast = _HTML$parse.ast, sourceNodes = _HTML$parse.nodes;
          css.replace(cssStyleRuleRegexp, function (_, selector, cssText) {
            // .foo {}
            if (!cssText) {
              return;
            }
            var nodes = filterNodes(sourceNodes, selector);
            if (nodes.length) {
              var specificity = spec.getSpecificity(selector);
              var classMetadata = {};

              // TODO: why /\s*(.*?)\s*:\s*(.*?);?/g doesn't work ?
              cssText.replace(/\s*(.*?)\s*:\s*([^;]*);?/g, function (_, prop, value) {
                styleToTailwind(selector, prop, value, specificity, classMetadata);
              });
              for (var i = 0, l = nodes.length; i < l; i++) {
                var _classMetadata = deepClone(classMetadata);
                var node = nodes[i];
                var source = node.classMetadata;
                if (!source) {
                  node.classMetadata = _classMetadata;
                } else {
                  for (var key in _classMetadata) {
                    var value = _classMetadata[key];
                    if (!source[key] || source[key].specificity <= value.specificity) {
                      source[key] = value;
                    }
                  }
                }
              }
            }
          });
          for (i = 0, l = sourceNodes.length; i < l; i++) {
            node = sourceNodes[i];
            classMetadata = node.classMetadata;
            if (classMetadata) {
              node.tailwindExp = classMetadataToTailwindExp(classMetadata);
            }
          }

          // import tailwind for test
          ast.children[0].children[0].children.push({
            type: 'tag',
            attrs: {
              src: 'https://cdn.tailwindcss.com'
            },
            parent: ast.children[0].children[0],
            tagName: 'script',
            children: []
          });
          res = HTML.stringify(ast);
          _context.next = 15;
          return writeFile(output, res);
        case 15:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function toTailwind(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
var src = toTailwind;

module.exports = src;
